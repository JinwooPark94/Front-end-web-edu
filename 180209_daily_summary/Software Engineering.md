# Software Engineering
소프트웨어의 개발, 운용, 유지보수 등의 생명 주기 전방을 체계적이고 서술적이며 정량적으로 다루는 학문

## 개발과 구현의 차이
### 개발
- 디자인, 분석하여 알맞은 framework를 사용하여 구현

### 구현

- 특정 컴퓨터 시스템에서의 소프트웨어 사용
- 컴퓨터 시스템 또는 정보 시스템 설치

## 소프트웨어 트렌드
- DevOps 사용
- 보안 needs
- Cloud computing
- 웹 및 모바일 앱과의 통합

### DevOps
- 기존의 개발과 운영 분리로 인해 발생하는 문제들
  > 문제 발생  -> 원인 분석 -> 문제해 결

- 좋은 소프트웨어를 위한 필수조건
  - 기획팀과 원활한 소통으로 요구사항 반영
  - 운영팀과 원활한 소통으로 소비자 불만과 의견 반영


![img](https://camo.githubusercontent.com/a3f082381622e2784f66675f0deb1820854c252c/687474703a2f2f6366696c65352e75662e746973746f72792e636f6d2f696d6167652f32323643393134463532384237304433333236364635)

## Software Development Life Cycle
### Requirements
무엇이 구현되어야 하는가에 대한 명세
시스템이 어떻게 동작해야 하는지 혹시 시스템의 특징이나 속성에 대한 설명

### 요구사항 분석
요구사항을 고려하여 새로운 제품이나 변경된 제품에 부합하는 요구와 조건을 결정하는 업무
> 길게 잡는 것이 좋음

`나와 사장님 모두를 만족시키기 위한 연결고리

- 요구사항 유도 : 대화를 통해 요구사항을 결정하는 작업
  > 메뉴,
- 요구사항 분석 : 수집한 요구사항을 분석하여 모순되거나 불완전한 사항을 해결하는 것
- 요구사항 기록 : 요구사항의 문서화 작업

### Requirements Layer

![img](https://github.com/ulgoon/wps-se/raw/master/img/r-layer.png)



## Business Requirements

### `Why`

왜 프로젝트를 수행하는지와 고객이 원하는 needs를 알아야 함

- 고객이 제품을 개발함으로서 얻을 수 있는 이득
- Vision and Scope

기획
실사용자가 제품을 통해서 어떤 것을 얻을 수 있는지 어떻게 움직이는지 어떤 서비스르 제공할건지



## User Requirements

### `What`

사용자가 이 제품을 통해 할 수 있는게 무엇인지 알아야 함

- Use cases
- Scenarios
- User stories
- Event-reponse tables

### 1. Use cases diagram

설명하는 방식

![img](https://camo.githubusercontent.com/b5574f1a822118af3d555d89893411c5f0796183/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f7468756d622f312f31642f5573655f636173655f72657374617572616e745f6d6f64656c2e7376672f33323070782d5573655f636173655f72657374617572616e745f6d6f64656c2e7376672e706e67)

### 2. user scenario

>  4시간 이상 걸릴시 프로젝트 사용 X

![img](https://camo.githubusercontent.com/e3acd8dc76a60dfe41c2cdc4bf9c55680982c27c/687474703a2f2f7777772e7061726163687574656469676974616c6d61726b6574696e672e636f6d2e61752f77702d636f6e74656e742f75706c6f6164732f323031322f30382f576562736974652d557365722d7363656e6172696f2d776f726b666c6f772e706e67)

### 3. User stories

기능별로 자르는 방식

![img](https://camo.githubusercontent.com/2112b73e136a3c9fbd6bb1274405d27b3af16b7a/68747470733a2f2f693137796a337237736c6a326867733378323434756579397a2d7770656e67696e652e6e6574646e612d73736c2e636f6d2f77702d636f6e74656e742f75706c6f6164732f6564642f323031362f30332f4244554b2d36332d557365722d53746f72792d4d61702d54656d706c6174652d4167696c652d7630352d322d72656c65617365732d383530783630302e706e67)

## Functional Requirements

개발자가 `무엇`을 개발할 것인지 명확하게 전달함

- '~ 해야 한다'로 끝나 반드시 수행해야 하거나 사용자가 할 수 있어야 하는 것에 대해 작성



## System Requirements

여러개의 서브 시스템으로 구성되는 제품에 대한 최상위 요구사항을 설명

## Business Rules

비즈니스 스트럭쳐의 요구나 제약사항을 명세

> "유저 로그인을 위해서는 페이스북 계정이 있어야 한다."

`애매한 표현은 사용하면 안되고 '있어야 한다'라고 정확히 명시를 해야함`

**5W(Why, What, When, Where, Who) 형식으로 자세히 물어봐야함 **

### Quality Attribute

- 소프트웨어의 품질에 대해 명세
- "결제과정에서 100명의 사용자가 평균 1.5초의 지연시간 안에 요청을 처리해야 한다"

>  `백앤드`에서 처리

### External Interface

- 시스템과 외부를 연결하는 인터페이스
- 다른 소프트웨어, 하드웨어, 통신 인터페이스, 프로토콜

### Constraint

- 기술, 표준, 업무, 법, 제도 등의 제약조건 명세
- 개발자들의 선택사항에 제한을 두는 것

### 지나치게 자세한 명세작성

- 명세서는 말 그대로 명세일 뿐, 실제 개발 단계에서 마주칠 모든 것을 담을 수 없음
- 개발을 언어로 모두 표현할 수 없음
- 명세서가 완벽하다고 해서 상품도 완벽하리란 보장은 없음
- 때로는 명세를 작성하기 보단 프로토타이핑이 더 간단할 수 있음

# Software Development Lifecycle Process Model

## 1. Build-fix Model

- 설계없이 일단 개발, 만족할 때까지 수정
- 시작이 빠름
- 계획이 정확하지 않음, 개발 문서가 없고 진행상황 파악이 힘듬

![img](https://camo.githubusercontent.com/9bd26d1b4da13ffeb9dd2b22cc868bce1b682661/687474703a2f2f696d6167652e736c696465736861726563646e2e636f6d2f6c656374757265332d736f66747761726570726f636573736d6f64656c2d3134313032393036343734332d636f6e76657273696f6e2d6761746530322f39352f6c6563747572652d332d736f6674776172652d70726f636573732d6d6f64656c2d342d3633382e6a70673f63623d31343134353635363436)

> 제일 안좋은 방법

## 2. Waterfall Model 

- 순차적인 개발 모델, 가장 많이 사용됨
- 정형화된 접근 가능, 체계적인 문서화 가능
- 직전 단계가 완료되어야 진행 가능

![img](https://camo.githubusercontent.com/4d3e9948674ebadd04af58d5f399a6519b162339/687474703a2f2f312e62702e626c6f6773706f742e636f6d2f2d67786a3945456d614b43632f5558667336643344325a492f4141414141414141417a492f6452657075654e77574b302f73313630302f776174657266616c6c2d6d6f64656c2d73646c63312e6a7067)

## 3. Prototype Model 

- 고객 요구사항을 적극적으로 반영하는 모델
- 빠른 개발과 고객 피드백을 빠르게 반영할 수 있음
- 대규모 프로젝트에 적용하기 힘듬

![img](https://camo.githubusercontent.com/1b83e0aea69edad5253717a8784fa1e31040ebca/687474703a2f2f73686f7065656d6172742e776565626c792e636f6d2f75706c6f6164732f322f392f352f312f32393531363539352f383735353333345f6f7269672e6a7067)

## 4. Spiral Model

- 대규모 or 고비용 프로젝트
- 프로젝트의 위험요인을 제거해 나갈 수 있음
- 각 단계가 명확하지 않음


![img](https://camo.githubusercontent.com/f5fe0d52b684a853ddc5cf6466c0d664410daa5d/687474703a2f2f6c65616e736f667477617265656e67696e656572696e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323030382f30352f73706972616c5f6d6f64656c5f626f65686d5f313938382e706e67)


## TDD (Test Driven Development)

- 어떤 것에 대한 모든 에러를 작성하여 테스트 코드를 짜야함 
- 객체지향적
- 재설계 시간 단축
- 디버깅 시간 단축
- 애자일과의 시너지(사용자 중심적)
- 테스트 문서 대체
- 추가 구현 용이